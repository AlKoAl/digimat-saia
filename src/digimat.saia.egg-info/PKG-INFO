Metadata-Version: 1.0
Name: digimat.saia
Version: 0.0.16
Summary: Digimat Saia EtherSBus (partial) client+server implementation
Home-page: http://www.digimat.ch
Author: Frederic Hess
Author-email: fhess@st-sa.ch
License: PSF
Description: ===================
        Python digimat.saia
        ===================
        
        This is a Python 2.7 module allowing to create client+server `SAIA EtherSBus <https://wiki.wireshark.org/EtherSBus>`_  nodes. In the exemple above, a local
        SBus node with address 253 (station number, or localid, or lid in our terminology) is created. 
        
        .. code-block:: python
        
            from digimat.saia import SAIANode
        
            node=SAIANode(253)
            node.start()
        
            [...]
        
            node.stop()
        
        
        SAIA EtherSBus
        --------------
        
        The EtherSBus is mainly an UDP encapsulated version of the serial SAIA S-Bus. The EtherSBus is natively implemented
        in most recent SAIA nodes, providing an easy way to exchange (read/write) information with 3rd party devices. The digimat.saia module
        was mainly created to partially explore the S-Bus mecanisms on Raspberry Pi devices before starting a deeper implementation
        on our `Digimat <https://www.st-sa.ch/digimat.html>`_ HVAC BMS infrastructure. 
        
        Please consider this work as in progress (**buggy and incomplete**).
        
        At this time, we don't have access to any S-Bus or EtherSBus protocol official specifications. If you own such documentation,
        please forward it to us (fhess@st-sa.ch), as SAIA doesn't want to provide it ;( Some good starting points may include :
        
        * `SAIA faq <http://www.sbc-support.ch/faq>`_
        * `WireShark EtherSBus plugin source code <https://github.com/boundary/wireshark/blob/master/epan/dissectors/packet-sbus.c>`_
        * `SBPoll Python EtherSBus source code <http://mblogic.sourceforge.net/mbtools/sbpoll.html>`_
        
        Using the SAIA PG5 debugger may also help understanding how things works. Wireshark has an excellent protocol decoder 
        and you will find some .pcap samples by googling "sbus pcap".
        
        Don't forget that the SAIA dynamic addressing won't be your friend here as you must know the address of the variable
        you want read/write. Consider fixing your variables to "static" addresses in your PG5 configuartion.
        
        
        Installation
        ------------
        
        Nothing specific here, just use pip (which will also install the digimat.jobs module)
        
        .. code-block:: bash
        
            pip install -U digimat.saia
        
        
        EtherSBus Node
        --------------
        
        Once created, the SAIANode object will implicitely start a background task responsible for protocol and bus variables management.
        The task must be stop()ed before the program termination. The node contains a server (allowing other nodes to read an write 
        data to it). The node can also donnect to other remote SBus servers, to read/write remote data. Each server (local or remote)
        has it's own memory representation (SAIAMemory).
        
        The SAIAMemory object handle every SBus variables (inputs, outputs, flags, registers). The SAIAMemory object provide a SAIAFlags object, 
        accessible trough a .flags property, itself providing access to every registered SAIAItemFlag object (item). The same principle is used for inputs 
        (SAIAItemInputs), outputs (SAIAItemOutputs) and registers (SAIAItemRegisters). Note that there are shortcuts implemented : 
        *node.flags* can be used instead of *node.memory.flags*.
        
        .. code-block:: python
        
            >>> myflag=node.memory.flags[18]
        
            >>> myflag
            <class 'digimat.saia.memory.SAIAItemFlag'>
        
            >>> myflag.value=True
            >>> print myflag.value
            True
        
        The SAIAMemory object is initially created *empty* (with no items declared). Items are dynamically instanciated "on-the-fly" when they are accessed. In the example above,
        the flag 18 is created on the first call, and returned in a SAIAItemFlag object. Subsequent calls to this item will always return the same object instance.
        Each item provide some helpers methods to facilitate value manipulation
        
        .. code-block:: python
        
            myflag.off()
            myflag.on()
            myflag.toggle()
            myflag.set()
            myflag.clear()
            myflag.value=1
            myflag.value=True
            print myflag.value
        
        By default, "on-the-fly-item-creation" is active. This means that any data item (flag, input, output, register) which is accessed (locally or remotely)
        will be dynamically instanciated if it doesn't exists.  This can create a large amount of unwanted memory consumption in case of abuse or bug. This mode can
        be disabled, and accessing a non pre-declared item will fail.
        
        .. code-block:: python
        
            >>> node.memory.enableOnTheFlyItemCreation(False)
            >>> print node.memory.flags[19]
            None
        
        Items can created by "declaring" them
        
        .. code-block:: python
        
            >>> myflag=node.memory.flags.declare(index=18)
            >>> myflags=node.flags.declareRange(index=100, count=3)
            >>> print myflags
            [127.0.0.1(253).SAIAItemFlag[100](value=OFF, age=1502487757s),
            127.0.0.1(253).SAIAItemFlag[101](value=OFF, age=1502487757s),
            127.0.0.1(253).SAIAItemFlag[102](value=OFF, age=1502487757s)]
        
        Inputs, Outputs and Flags are boolean items. Registers are simple "32 bits uint values".
        
        .. code-block:: python
        
            >>> myregister=node.memory.registers[0]
            >>> myregister.value=100
            >>> print register.value
            100
        
        They are always stored as "raw" values (without format). Helpers are available to set/get the register value with common encodings
        
        .. code-block:: python
        
            >>> myregister.float32=21.5
            >>> print myregister.value
            1101791232
            >>> print myregister.float32
            21.5
        
        Actually, the following encoders/decoders accessors are implemented
        
        * .float32 --> IEEE float32 encoding (big-endian)
        * .sfloat32 --> Swapped IEEE float32 encoding (little-endian)
        * .ffp --> Motorola Fast Floating Point encoding (SAIA Float)
        * .int10 --> x10 rounded value (21.5275 is encoded as 215)
        
        As in SAIA float values seems to be FFP encoded, the ffp encoder is automatically used
        when writing a float value to a register (instead of an int)
        
        .. code-block:: python
        
            >>> myregister.value=2
            >>> print myregister.value
            2
            >>> myregister.value=2.0
            >>> print myregister.value
            2147483714
            >>> print myregister.fft
            2.0
        
        
        EtherSBus Client
        ----------------
        
        The node object allow access to (as many) remote EtherSBus nodes you need
        
        .. code-block:: python
        
            >>> server=node.registerServer('192.168.0.100')
            >>> myRemoteFlag=server.memory.flags[5]
        
        The registration process provide a SAIAServer, containing a SAIAMemory object to access remote items. Local and remote data can be manipulated 
        in the same manner. When a remote data item (input, output, flag, register) is declared, an automatic pooling mecanism is launched in 
        the background task. Refresh can also manually be triggered with a myRemoteFlag.refresh() call. You can query the elapsed time (in seconds) since
        the last value update (refresh) with the myRemoteFlag.age() method. Changing the remote data value is fully transparent
        
        .. code-block:: python
        
            >>> myRemoteFlag.value=1
        
        For a non local object, this will queue a write order in the SAIAServer object with the new given value. The actual value of the item
        remains unchanged. When the write order has been executed, a refresh order is immediately triggered, thus allowing the actual value to be updated. 
        This tend to keep the value synchonized with the remote value, even if something goes wrong. 
        
        The background manager try to be as reactive and idle as possible, keeping ressources for your application. We tried to
        trap most of the possible errors, allowing using this module to be used as a standalone service. Note that automatic SAIA address 
        resolution is implemented, so that only remote IP address is required to register a remote node. If known, the SAIA station address *can* be
        given during registration
        
        .. code-block:: python
        
            >>> server=node.registerServer(host, lid=54, port=5050)
        
        
        Dumping & Debugging
        -------------------
        
        The module use a lot of tcp logging. Limited debug can also be done with objects .dump() methods. Try node.dump() or node.memory.dump()
        or node.memory.flags.dump(). For debugging purposes, you can simulate a remote node by registering a remote node by pointing on yourself
        
        .. code-block:: python
        
            >>> server=node.registerServer('127.0.0.1')
            >>> localFlag=node.memory.flags[1]
            >>> remoteFlag=server.memory.flags[1]
        
            >>> print localFlag.value, remoteFlag.value
            False, False
        
            >>> remoteFlag.value=1
        
            # network data synchronisation is done by the background manager task
        
            >>> print localFlag.value
            True
        
        In this example, localFlag and remoteFlag points to the same data, but the remoteFlag is a networked synchonized 
        mirror representation of the localFlag.  The SAIA PG5 Online Debugger can be partially used with the local node.
        
        .. code-block:: python
        
            import time
            from digimat.saia import SAIANode
        
            node=SAIANode()
        
            while True:
                try:
                    time.sleep(3.0)
                    node.dump()
                except:
                    break
        
            node.stop()
        
        
        Open your SAIA Debugger on this node, and try reading/writing some items. You acn also use clear request with i,o,f and r items.
        
        
        Documentation
        -------------
        
        To be continued. Writing in progress ;) don't know if this is useful for someone.
        
Platform: UNKNOWN
